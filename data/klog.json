{
 "common_error_warning_patterns": 
 [ 
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS_THERMAL",
   "pattern": "Temperature above threshold, cpu clock throttled",
   "advice": "Test caused CPU temperature above critical threshold. Insufficient cooling?",
   "label": "CommonThermalOverrun"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "BIOS never enumerated boot CPU",
   "advice": "The boot processor is not enumerated!",
   "label": "CommonBiosBootCpuNotEnumerated"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_HOTPLUG",
   "pattern": "acpi_shpchprm.*_HPP fail",
   "advice": "Hotplug _HPP method failed",
   "label": "CommonAcpiHppMethodFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_HOTPLUG",
   "pattern": "shpchp.*acpi_pciehprm.*OSHP fail",
   "advice": "ACPI Hotplug OSHP method failed",
   "label": "CommonAcpiHotplugOshpMethodFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_HOTPLUG",
   "pattern": "shpchp.*acpi_shpchprm.*evaluate _BBN fail",
   "advice": "Hotplug _BBN method is missing",
   "label": "CommonAcpiHotPlugBbnMissing"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error while parsing _PSD domain information",
   "advice": "_PSD domain information is corrupt!",
   "label": "CommonAcpiPsdParsingError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Wrong _BBN value, reboot and use option 'pci=noacpi'",
   "advice": "The BIOS has wrong _BBN value, which will make PCI root bridge have wrong bus number",
   "label": "CommonAcpiWrongBbnValue"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_APIC",
   "pattern": "ACPI.*apic on CPU.* stops in C2",
   "advice": "The local apic timer incorrectly stops during C2 idle state.The ACPI specification forbids this and Linux needs the local APIC timer to work. The most likely cause of this is that the firmware uses a hardware C3 or C4 state that is mapped to the ACPI C2 state.",
   "label": "CommonAcpiApicStopsInC2"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS_IRQ",
   "pattern": "Disabling IRQ",
   "advice": "The kernel detected an irq storm. This is most probably an IRQ routing bug.",
   "label": "CommonBiosIrqRoutingBug"
  }
 ],
 "firmware_error_warning_patterns":
 [
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid type .* for target of Scope operator .*Cannot override",
   "advice": "The ACPI interpreter found an invalid type for target of a scope operator, this occurred during the loading of the ACPI tables, see acpi_ds_load2_begin_op().",
   "label": "KlogAcpiInvalidTypeScopeOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Divide by zero",
   "advice": "The ACPI interpreter detected a zero divisor which produce a division by zero error.  The AML code is buggy and this will return an undefined value that may cause unexpected behaviour.",
   "label": "KlogAcpiAmlDivideByZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not release AML Interpreter mutex",
   "advice": "The ACPI AML interpreter attempted to release the mutex but this failed. The next time interpreter will attempt to acquire this mutex it will fail, however it will continue to execute AML but there will be race conditions occurring.",
   "label": "KlogAcpiAmlMutexNotReleased"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not map memory at 0x.* for length",
   "advice": "ACPI could not memory map the Extended BIOS Data Area (EBDA) or upper region 0xE0000-0xFFFFF to search for the ACPI RSDP.  This normally results in the RSDP not being found, which means the ACPI tables can't be located and hence ACPI is disabled.",
   "label": "KlogAcpiRsdpMemMap"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid zero ID from AcpiOsGetThreadId",
   "advice": "A zero thread ID was returned which will break the ACPI driver.  This should never happen, since the thread ID is actually the address of the thread descriptor which is never zero.",
   "label": "KlogAcpiZeroThreadId"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown action (0x",
   "advice": "The ACPI engine was expecting to increment, decrement or delete a reference count but instead was given an uknown action to do instead.  This is a bug in the ACPI ACPICA code.",
   "label": "KlogAcpiRefCountUnknownAction"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Null Op",
   "advice": "The ACPI interpreter found a NULL parse opcode and didn't expect to. See acpi_ds_delete_result_if_not_used() or acpi_ds_is_result_used().",
   "label": "KlogAcpiNullOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown parent opcode Op=",
   "advice": "The ACPI interpreter found an AML opcode that had an unexpected parent class. This probably indicates an internal ACPI interpeter bug. ",
   "label": "KlogAcpiUnknownParentOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Time parameter is too large",
   "advice": "ACPI Stall() op was requested to wait for more than 255 usec.  The ACPI specification states that the maximum should be 100 usec but to accommodate some firmware a maximum of 255 is supported by the kernel.",
   "label": "KlogAcpiStallTooLarge"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BRIGHTNESS",
   "pattern": "Evaluating _BCM failed",
   "advice": "Could not set the brightness level, the ACPI control _BCM failed to execute correctly.",
   "label": "KlogAcpiBcmFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BRIGHTNESS",
   "pattern": "Current brightness invalid",
   "advice": "The ACPI video driver set the brightness level using the ACPI control _BCM, however the level used was not a known level (as returned by _BCL).",
   "label": "KlogAcpiInvalidBrightness"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Too many duplicates in _BCL package",
   "advice": "ACPI method _BCL (Query List of Brightness Control Levels Supported) contains too many duplicated brightness levels in the returned package and this is non-standard.",
   "label": "KlogAcpiBclPackageContainsDuplicates"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Found unordered _BCL package",
   "advice": "ACPI method _BCL (Query List of Brightness Control Levels Supported) has a maximum brightness value which is not the last value in the returned package. Values returned must be in ascending order.",
   "label": "KlogAcpiBclUnorderedPackage"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Subsystem is already terminated",
   "advice": "A request to terminate the ACPI driver but it is already terminated. You should not see this error.",
   "label": "KlogAcpiAlreadyTerminated"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Null scope parameter",
   "advice": "Failed to push the current scope onto the scope stack, the node was Null, which was not expected. See acpi_ds_scope_stack_push().",
   "label": "KlogAcpiNullScopeParameter"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid conversion sub-opcode",
   "advice": "The ACPI driver could not convert an AML resource descriptor to a corresponding internal resource descriptor. Refer to acpi_rs_convert_aml_to_resource() or acpi_rs_convert_resource_to_aml().",
   "label": "KlogAcpiConversionSupOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid conversion opcode",
   "advice": "The ACPI driver could not convert an AML resource descriptor to a corresponding internal resource descriptor. Refer to acpi_rs_convert_aml_to_resource() or acpi_rs_convert_resource_to_aml().",
   "label": "KlogAcpiConversionSupOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No SMI_CMD in FADT, mode transition failed",
   "advice": "ACPI FADT SMI_CMD is zero, with ACPI 2.0 this means that the system cannot transtion to/from ACPI mode.",
   "label": "KlogAcpiFadtSmiCmdZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No ACPI mode transition supported in this system (enable/disable both zero)",
   "advice": "ACPI FADT ACPI_ENABLE is zero and ACPI_DISABLE is set, ACPI 2.0 this means enabling or disabling is not supported and the system cannot transition to ACPI mode.",
   "label": "KlogAcpiNoModeTransitionSupport"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Found a grandchild.*P=.*C=",
   "advice": "An error occured in the ACPI driver, acpi_ns_delete_children() was trying to delete children objects and discovered that one of these had children objects of it's own, which should not happen.",
   "label": "KlogAcpiObjectGrandchild"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Cannot assign type .* to .*must be type Int/Str/Buf",
   "advice": "ACPI execution run time error: Type assignment was illegal, acpi_ex_resolve_object() was trying assign a type to a different type which is illegal.",
   "label": "KlogAcpiTypeAssign"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Store into an unresolved Alias object",
   "advice": "ACPI execution run time error: The ACPI driver has been asked to resolve an object of type ACPI_TYPE_LOCAL_ALIAS or ACPI_TYPE_LOCAL_METHOD_ALIAS but this should not occur as these should have been resolved earlier. See function acpi_ex_resolve_object() for more details.",
   "label": "KlogAcpiUnresolveAliasObject"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown AML opcode 0x",
   "advice": "ACPI execution run time error: The ACPI interpreter has reached an opcode that is unknown, this normally is a bug in the underlying AML code either because of badly written AML code or the compiler has produced code that is incorrect or the ACPI interpreter does not support this valid opcode. ",
   "label": "KlogAcpiUnknownAmlOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid AML Opcode: 0x",
   "advice": "ACPI execution run time error: The ACPI interpreter has reached an opcode that is unknown, this normally is a bug in the underlying AML code either because of badly written AML code or the compiler has produced code that is incorrect or the ACPI interpreter does not support this valid opcode. ",
   "label": "KlogAcpiUnknownAmlOpcode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Found unknown opcode .* at AML address .* offset",
   "advice": "ACPI execution run time error: The ACPI interpreter has reached an opcode that is unknown, this normally is a bug in the underlying AML code either because of badly written AML code or the compiler has produced code that is incorrect or the ACPI interpreter does not support this valid opcode. ",
   "label": "KlogAcpiUnknownAmlOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "BCD digit too large (not decimal): 0x",
   "advice": "ACPI execution run time error: AML opcode AML_FROM_BCD_OP (0x5b28) contains a BCD digit value that is greater than 9 and is out of range for a Binary Coded Decimal digit.",
   "label": "KlogAcpiBcdDigitTooLarge"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Integer too large to convert to BCD",
   "advice": "ACPI execution run time error: AML opcode AML_TO_BCD_OP (0x5b29) has been requested to convert an integer into a Binary Coded Decimal value that is too large. An overflow has been caught and it is possible that unexpected execution behaviour will occur.",
   "label": "KlogAcpiToBcdOverflow"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "obsolete and not implemented",
   "advice": "ACPI execution run time error: Execution of AML_SHIFT_LEFT_BIT_OP (0x5b11) or AML_SHIFT_RIGHT_BIT_OP (0x5b10) were ignored, these are obsolete AML opcodes and are not implemented in the ACPI interpreter. Unexepcted execution behaviour will occur.",
   "label": "KlogAcpiOpObsolete"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Operand must be Buffer/Integer/String/Package - found type",
   "advice": "ACPI execution run time error: Execution of AML_SIZE_OF_OP with an operand that is not a buffer, integer, string or package has occurred. This will result in unexpected behaviour. This is a bug in the AML.",
   "label": "KlogAcpiOpTypeBad"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown Index TargetType 0x",
   "advice": "ACPI execution run time error: Execution of AML_DEREF_OF_OP (0x83) with an illegal target index operator that was not a buffer or a package type.",
   "label": "KlogAcpiUnknownIndexTargetType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown class in reference",
   "advice": "ACPI execution run time error: Execution of AML_DEREF_OF_OP (0x83) with an illegal operand reference class.",
   "label": "KlogAcpiUnknownIndexTargetType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "apm.*an event queue overflowed",
   "advice": "More then 20 APM events were queued up which is unexpected.  The queue was not being drained quickly by a reading process (perhaps it is not running).",
   "label": "KlogApmEventQueueOverflow"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "apm.*passed bad filp",
   "advice": "A read of the APM events was performed by a reading process with an unrecognised file pointer. This should not happen.",
   "label": "KlogApmReadBadFileptr"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "apm.*filp not in user list",
   "advice": "An attempt to release a APM reader occurred using an unrecognised file pointer. This should not happen.",
   "label": "KlogApmReleaseBadFileptr"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "apm.*cannot allocate struct of size %d bytes",
   "advice": "An attempt to open failed, out of memory. APM events cannot be read.",
   "label": "KlogApmOpenNoMemory"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "apm.*disabled - Unable to start kernel thread",
   "advice": "Cannot start kernel APM thread, APM handling will be disabled.",
   "label": "KlogApmKernelThreadFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "PnPBIOS.*ESCD size reported by BIOS escd_info call is too great",
   "advice": "The ESCD size was greater than a sane size of 32K.",
   "label": "KlogPnpBiosEscdSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "PnPBIOS.*ESCD size reported by BIOS read_escd call is too great",
   "advice": "The ESCD size was greater than a sane size of 32K.",
   "label": "KlogPnpBiosEscdSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "PnPBIOS.*",
   "advice": "The PnPBIOS driver has detected an issue that fwts does not know about.",
   "label": "KlogPnpBiosError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Node number .* is out of sequence following node .* Aborting.",
   "advice": "Device node numbers are out of sequence.",
   "label": "KlogPnpBiosDevNodeSeqError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "PCI: BIOS BUG #",
   "advice": "A call to the PCI BIOS32 service routine (with service signature $PCI) has returned a bad status or an illegal PCI signature. The kernel will disable the use of the PCI BIOS.",
   "label": "KlogBios32PciFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "e820: too many entries; ignoring ",
   "advice": "Legacy E820 BIOS has a limit of 128 entries in the E820 memory map but the firmware seems to have more than this. For EFI Numa hardare, the limit is 128 + 3 * maximum number of nodes.  The kernel has ignore the extra entries.  This could lead to regions of memory being used by the kernel when in fact is should be reserved and this can lead to unexpected behaviour.",
   "label": "KlogE820TooManyEntries"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Ooops! Too many entries in the memory map!",
   "advice": "Legacy E820 BIOS has a limit of 128 entries in the E820 memory map but the firmware seems to have more than this. For EFI Numa hardare, the limit is 128 + 3 * maximum number of nodes.  The kernel has ignore the extra entries.  This could lead to regions of memory being used by the kernel when in fact is should be reserved and this can lead to unexpected behaviour.",
   "label": "KlogE820TooManyEntries"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_LOW",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "MTRR.*CPU.*SYSCFG.*MtrrFixDramModEn.*not cleared by BIOS, clearing this bit",
   "advice": "The firmware is expected to clear MtrrFixDramModEn bit, see for example BIOS and Kernel Developer's Guide for the AMD Athlon 64 and AMD Opteron Processors (26094 Rev. 3.30 February 2006), section 13.2.1.2 SYSCFG Register. The MtrrFixDramModEn bit should be set 1 during firmware initalization of the fixed MTRRs, then cleared to 0 for operation. Hence the kernel has detected and worked around this fault.",
   "label": "KlogMtrrFixDramModEnNotClear"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "MTRR.*CPU.*Writing MSR .* to .* failed",
   "advice": "Writing to a MTRR MSR has failed. The kernel cannot do much about this and has ignored the failure.",
   "label": "KlogMtrrWriteMsrFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "acpi_request_vector.*invalid interrupt type",
   "advice": "An attempt to request an interrupt vector greater than 256 (ACPI_MAX_PLATFORM_INTERRUPTS) has occurred and will be rejected.",
   "label": "KlogAcpiIa64RequestBadVector"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Can't find MADT",
   "advice": "Could not find the ACPI MADT. The kernel could not find this table so it could determine how many CPUs the system had.  The machine will boot with just one CPU which may be the incorrect number of CPUs.",
   "label": "KlogAcpiMadtMissing"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Error parsing MADT - no LAPIC entries",
   "advice": "The ACPI MADT could not be parsed to determine the number of Local APIC entries.  This may lead to sub-optimal configuration of the machine.",
   "label": "KlogAcpiMadtLapicParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Error parsing LAPIC address override entry",
   "advice": "The ACPI MADT could not be parsed to determine the Local APIC override entry.",
   "label": "KlogAcpiMadtLapiceOverrideParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Error parsing LAPIC NMI entry",
   "advice": "The ACPI MADT could not be parsed to determine the Local APIC NMI entry.",
   "label": "KlogAcpiMadtLapicNmiParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Error parsing MADT.*no IOSAPIC entries",
   "advice": "The ACPI MADT could not be parsed to find the IOSAPIC entries.",
   "label": "KlogAcpiMadtIosapicParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Error parsing platform interrupt source entry",
   "advice": "The ACPI MADT could not be parsed to find the platform intrerrupt source entry.",
   "label": "KlogAcpiMadtPlatIntSrcParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Can't find FADT",
   "advice": "The ACPI Fixed ACPI Description Table (FADT) is missing and so the kernel cannot determine if the legacy keyboard controller is present.  It cannot also determine the SCI_INT interrupt line which is used for ACPI events, such as the power and sleep buttons. If the SCI_INT is not on a legacy interrupt then it needs to be specified in the FADT. ",
   "label": "KlogAcpiFadtMissing"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Cannot create",
   "advice": "The ACPI driver attempted to create an entry in /proc/acpi but failed. This should not happen and is a kernel bug.",
   "label": "KlogAcpiProcfsCreateFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Create sysfs link",
   "advice": "The ACPI driver attempted to create a sysfs link for a device and this failed. This should not happen and is a kernel bug.",
   "label": "KlogAcpiSysfsLinkCreateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error updating fan power state",
   "advice": "Failed to update the fan power state when coming out of resume. The call to acpi_bus_update_power() failed even though the fan device was valid.",
   "label": "KlogAcpiFanResumeUpdate"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "does not support this state",
   "advice": "A request to suspend the machine was aborted because it was asked to transition to a sleep state that is not supported by the ACPI driver or this machine.",
   "label": "KlogAcpiUnsupportedSleepState"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Hardware changed while hibernated, cannot resume",
   "advice": "The FACS hardware signature has changed when coming out of hibernation. The kernel has concluded that the machine has changed and therefore won't commit to resuming from hibernate.",
   "label": "KlogAcpiS4ResumeBadFacsSignature"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Device don't exist, dropping EJECT",
   "advice": "A processor hotplug notify eject request event was rejected because the device does not seem to exist.",
   "label": "KlogAcpiHotPlugEjectMissingDevice"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Driver data is NULL, dropping EJECT",
   "advice": "A processor hotplug notify eject request event was rejected because the device data is NULL.",
   "label": "KlogAcpiHotplugEjectNullDeviceData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid reference to IOAPIC pin",
   "advice": "The IOAPIC pin was invalid, it exceeded the maximum expected pin reference value (MP_MAX_IOAPIC_PIN 127).",
   "label": "KlogAcpiIoApicPinRefInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error parsing IOAPIC entry",
   "advice": "Failed to parse the ACPI MADT, the number of IOAPIC entries found was less than zero, which probably means the MADT is broken.",
   "label": "KlogAcpiMadtParseError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No IOAPIC entries present",
   "advice": "The ACPI MADT was expected to contain at least one IOAPIC entry, however, none were found. Cannot enumerate the IOAPICs.",
   "label": "KlogAcpiMadtNoIoApicEntry"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error parsing interrupt source overrides entry",
   "advice": "Could not parse the ACPI MADT to determine the interrupt override for the SCI. This could lead to unexpected behaviour.",
   "label": "KlogAcpiMadtIrqOverrideParseError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error parsing NMI SRC entry",
   "advice": "Could not parse the ACPI MADT to determine the NMI SRC entry. This could lead to unexpected behaviour.",
   "label": "KlogAcpiMadtNmiSrcEntryParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "pci_create_slot returned",
   "advice": "A PCI slot could not be register because a call to pci_create_slot() failed.",
   "label": "KlogAcpiPciSlot"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "walk_p2p_bridge failure",
   "advice": "Traversing the PCI root bridge failed because of an error walking the P2P bridge.",
   "label": "KlogAcpiPciSlot"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "register_slot failure",
   "advice": "Adding a PCI slot failed because traversing the PCI root bridge failed.",
   "label": "KlogAcpiPciSlot"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_PRS resource type .* isn't an IRQ",
   "advice": "The ACPI _PRS resource type was expected to be an IRQ type and was not.",
   "label": "KlogAcpiPciLinkPrsIrq"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_CRS resource type 0x%x isn't an IRQ",
   "advice": "The ACPI _CRS resource type was expected to be an IRQ type and was not.",
   "label": "KlogAcpiPciLinkCrsIrq"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI:.*Unable to read status",
   "advice": "A query of _STA to get the bus status failed and the current link status is unknown.",
   "label": "KlogAcpiPciLinkSta"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_CRS returned 0",
   "advice": "The query of the bus status failed because the _CRS controlled returned IRQ 0, which was not expected.",
   "label": "KlogAcpiPciLinkCrsIrqZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid Resource_type",
   "advice": "A PCI link set failed because the link IRQ resource type is invalid.",
   "label": "KlogAcpiPciLinkIrqResourceInvalid"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to set IRQ for",
   "advice": "An attempt to enabled the link device failed.",
   "label": "KlogAcpiPciLinkFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid link device",
   "advice": "Unable to allocate an IRQ failed because the link device is invalid.",
   "label": "KlogAcpiPciLinkDeviceInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid link context",
   "advice": "Unable to allocate an IRQ failed because the link context was invalid (NULL).",
   "label": "KlogAcpiPciLinkContextNull"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Invalid index",
   "advice": "Support for multiple index IRQ entries per link device is not yet implemented.",
   "label": "KlogAcpiPciLinkMultipleIrqEntries"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Link active IRQ is 0",
   "advice": "Unable to allocate an IRQ failed because the active IRQ is 0, which is wrong.",
   "label": "KlogAcpiPciLinkActiveIrqZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Link isn't initialized",
   "advice": "An attempt to free the IRQ of a link failed because the link was not initialized.",
   "label": "KlogAcpiPciLinkNotInitialized"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating processor object",
   "advice": "An error occurred evaluating the ACPI Processor() object, ACPI CPU control for this CPU broken.",
   "label": "KlogAcpiProcessorFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating processor _UID",
   "advice": "An error occurred evaluating an ACPI CPU _UID, ACPI CPU control for this CPU is broken.",
   "label": "KlogAcpiProcessorBadUid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid PBLK length",
   "advice": "The Processor Register Block data is not the expected size, ACPI control of this CPU will not occur.",
   "label": "KlogAcpiProcessorPblkBad"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _PSS data",
   "advice": "Failed to get ACPI performance states from the _PSS contol, buffer was either NULL or not an ACPI package.",
   "label": "KlogAcpiPssFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid BIOS _PSS frequency found for processor",
   "advice": "CPU frequency in MHz as supplied by _PSS control cannot be stored in a 32 bit unsigned integer, overflow error.",
   "label": "KlogAcpiPssFreqTooBig"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No valid BIOS _PSS frequency found for processor",
   "advice": "One of the CPUs did not have a valid _PSS frequency defined. Cannot fetch _PSS levels for this CPU.",
   "label": "KlogAcpiPssNotFound"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _PSD data",
   "advice": "The ACPI _PSD control returned a pointer that was NULL or not an ACPI package or did not have 1 item in the package or the item could not be fetched out of the package. P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown _PSD:num_entries",
   "advice": "The number of _PSD entries should be 5 but a different count was returned. The P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadCount"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown _PSD:revision",
   "advice": "The _PSD revision should be 0 but a different version was returned. P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadRevision"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _PSD:coord_type",
   "advice": "The _PSD coordination type was invalid, it should be SW_ALL, SW_ANY or HW_ALL. P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadCoordType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_VIDEO",
   "pattern": "Failed to switch the brightness",
   "advice": "The ACPI video brightness for the LCD could not be set because _BCM failed.",
   "label": "KlogAcpiVideoBcmFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_VIDEO",
   "pattern": "Invalid _DOD data in element",
   "advice": "The ACPI _DOD control returned an element that was not an ACPI integer as expected. This element will be ignored, which could lead to reduced functionality.",
   "label": "KlogAcpiVideoDodFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_VIDEO",
   "pattern": "Invalid _DDC data",
   "advice": "The ACPI _DDC control is returning either a NULL buffer pointer or data that is not an ACPI buffer. The Extended Display Identification Data (EDID) structure that represents the display output device could not be fetched. This may affect video output.",
   "label": "KlogAcpiVideoDdcFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_VIDEO",
   "pattern": "Invalid _BCL data",
   "advice": "The ACPI _BCL control is returning either a NULL buffer pointer or data that is not an ACPI package. LCD brightness level queries will not work.",
   "label": "KlogAcpiVideoBclFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Oops, 'acpi_handle' corrupt",
   "advice": "Failed to unbind a device, the ACPI handle was corrupt.",
   "label": "KlogAcpiHandleCorrupt"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Can't use platform_notify",
   "advice": "Cannot add the ACPI platform notifiers, they are already registered. This should not happen.",
   "label": "KlogAcpiPlatformNotify"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:Error in acpi_memory_enable_device",
   "advice": "Adding a hotplug memory device failed because.",
   "label": "KlogAcpiHotPlugAddMemDeviceFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_INFO",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:Disable memory device",
   "advice": "An ACPI notify eject request occurred to disable a memory device.",
   "label": "KlogAcpiHotPlugNotifyDisableOkay"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:Driver Data is NULL",
   "advice": "An ACPI notify eject request failed because the device data is NULL.",
   "label": "KlogAcpiHotPlugNotifyEjectDataNull"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Device doesn't exist",
   "advice": "An ACPI notify eject request failed because the device does not exist.",
   "label": "KlogAcpiHotPlugNotifyEjectDeviceNotExist"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:Cannot enable memory device",
   "advice": "Memory device notify failed because it could not enabled the memory device.",
   "label": "KlogAcpiHotPlugEnableFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:Cannot find driver data",
   "advice": "Memory device notify failed because it could not find the relevant driver data for this device.",
   "label": "KlogAcpiHotPlugDeviceNotify"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:add_memory failed",
   "advice": "Failed to add memory device, add_memory() failed for some reason.",
   "label": "KlogAcpiHotPlugAddMemoryFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:get_device_resources failed",
   "advice": "The devices resources could not be determined from the relevant ACPI _CRS control and so the memory device could not be enabled.",
   "label": "KlogAcpiHotPlugCrsFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Fatal opcode executed",
   "advice": "An ACPI AML fatal opcode was executed and the kernel has trapped this signal. It could be because of faulty control method code.",
   "label": "KlogAcpiFatalOpcodeSignal"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Call to queue_work() failed.",
   "advice": "Failed to queue up AML exec work on CPU 0. This results in ACPI control code not being executed which could lead to unexpected behaviour.",
   "label": "KlogAcpiQueueWorkFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "acpi_os_get_timer() TBD",
   "advice": "Support for the 64 bit ACPI AML timer operand is not implemented, this will be emulated and may affect AML code that relies on accurate timers.",
   "label": "KlogAcpiGetTimerNotImplemented"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "SCI .* allocation failed",
   "advice": "Failed to install an ACPI SCI interrupt handler because the the IRQ allocation failed.",
   "label": "KlogAcpiSciIrqAllocError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "SCI .*ACPI GSI .* not registered",
   "advice": "Failed to install an ACPI SCI interrupt handler because the Global System Interrupt (GSI) is not registered.",
   "label": "KlogAcpiSciGsiError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Cannot map memory that high",
   "advice": "Cannot map an ACPI physical address above the 32 bit 4GB limit, this could lead to broken functionality.",
   "label": "KlogAcpiMap4GbLimit"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "System description tables not found",
   "advice": "The EFI ACPI20 or ACPI RSDP pointers were invalid, so the kernel cannot find any of the ACPI tables.  ACPI support will be disabled.",
   "label": "KlogAcpiEfiRsdpError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Vendor .* System .* Revision .* has a known ACPI BIOS problem",
   "advice": "The kernel has recognised that this particular version of the firmware has known ACPI issues and so ACPI support will be disabled. Reduced functionality will occur.",
   "label": "KlogAcpiBlackListed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to register for device notifications",
   "advice": "The ACPI device notify handlers failed to be installed and so ACPI support with be disabled.",
   "label": "KlogAcpiNotifyHandlerInstallFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to initialize ACPI objects",
   "advice": "The ACPI objects failed to initialize and so ACPI support with be disabled.",
   "label": "KlogAcpiObjectsFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to start the ACPI Interpreter",
   "advice": "The ACPI interpreter failed to start up correctly and so ACPI support with be disabled.",
   "label": "KlogAcpiInterpreterFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to enable ACPI",
   "advice": "The ACPI subsystem failed to be enabled and so ACPI support with be disabled.",
   "label": "KlogAcpiEnableFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to load the System Description Tables",
   "advice": "The ACPI driver was unabled to load the ACPI tables and so ACPI support will be disabled.",
   "label": "KlogAcpiLoadFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to initialize the ACPI Interpreter",
   "advice": "The ACPI interpreter could not be intialized and so ACPI support will be disabled.",
   "label": "KlogAcpiInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to reallocate ACPI tables",
   "advice": "The kernel count not reallocate the ACPI tables into memory from firmware and so ACPI support will be disabled.",
   "label": "KlogAcpiReallocateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "can't evaluate _SEG",
   "advice": "The _SEG ACPI control could not be evaluated. This will stop certain PCI root bridges from being added and enabled on the computer.",
   "label": "KlogAcpiSegFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "can't evaluate _BBN",
   "advice": "The _BBN ACPI control could not be evaluated. This will stop certain PCI root bridges from being added and enabled on the computer.",
   "label": "KlogAcpiSegFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Bus .*:.* not present in PCI namespace",
   "advice": "The bus cound not be found in the PCI namespace. This will stop certain PCI root bridges from being added and enabled on the computer.",
   "label": "KlogAcpiPciScanFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_POWER",
   "pattern": "_DSW execution failed",
   "advice": "The ACPI control _DSW (Device Sleep Wake) failed to execute, this may impact on the ability to enable or disable the wake capabilities of a device in the computer.",
   "label": "KlogAcpiDswFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_POWER",
   "pattern": "_PSW execution failed",
   "advice": "The ACPI control _PSW (Power State Wake) failed to execute, this may impact on the ability to enable or disable the wake capabilities of a device in the computer.",
   "label": "KlogAcpiPswFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_POWER",
   "pattern": "Transition power state",
   "advice": "Failed to power on or shutdown a wakeup device using _PSW or _DSW control methods.",
   "label": "KlogAcpiSuspend"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_EMBEDDED_CONTROLLER",
   "pattern": "Fail in evaluating the _REG object of EC device",
   "advice": "The _REG object for the Embedded Controller Device could not be evaluated, however the kernel will ignore this and try to install the handler for the Embedded Controller.",
   "label": "KlogAcpiEcBadReg"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_DOCK",
   "pattern": "Unable to undock",
   "advice": "An undock event was requested but the machine still seems to be docked.",
   "label": "KlogAcpiDockCannotUndock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_DOCK",
   "pattern": "Unable to dock",
   "advice": "A dock notify event was handled but the machine still seems to be undocked.",
   "label": "KlogAcpiDockCannotDoct"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_DOCK",
   "pattern": "Unknown dock event",
   "advice": "A dock notify event was handled, but the type of notify event was not recognised.",
   "label": "KlogAcpiDockEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_DOCK",
   "pattern": ".* encountered error .*",
   "advice": "An error occurred when trying to add a new dock station device.",
   "label": "KlogAcpiDockAdd"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_BUTTON",
   "pattern": "More than one Lid device found",
   "advice": "Failed to add a Lid device because one already exists.  The kernel does not support more than one Lid device.",
   "label": "KlogAcpiLidMany"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_ACPI_BUTTON",
   "pattern": "Unsupported hid",
   "advice": "The Lid Hardware ID (HID) is one that the kernel does not recognise and so the Lid device was not added to the system. This can explain why the Lid does not work.",
   "label": "KlogAcpiLidBadHid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_CONTAINER",
   "pattern": "ACPI: device is NULL",
   "advice": "The kernel count not add a container because the device associated with this was NULL, which is unexexpected.",
   "label": "KlogAcpiContainer"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_ACPI_SUSPEND",
   "pattern": "wakeup header does not match",
   "advice": "The ACPI suspend wakeup header did not contain the expected header value so the kernel had to abort the suspend. This can happen if the data is corrupted.",
   "label": "KlogAcpiSuspendHeader"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "ACPI: not enough elements in _CST",
   "advice": "_CST returned either a NULL buffer or a type that wasn't an ACPI package or less than 2 elements in the package. The kernel could not evaluate the CPU supported C states supported, meaning that the machine will not run optimally.",
   "label": "KlogAcpiCstElements"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "ACPI: count given by _CST is not valid",
   "advice": "_CST returned an invalid number of elements, the package a different number of C states to the number of C states that _CST reported. The kernel could not evaluate the CPU supported C states supported, meaning that the machine will not run optimally.",
   "label": "KlogAcpiCstCount"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "No return object",
   "advice": "An ACPI evaluate for a reference returned a buffer of zero length or a NULL buffer pointer.",
   "label": "KlogAcpiEvalReferenceBadBuffer"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "Expecting a [Package], found type",
   "advice": "An ACPI evaluate for a reference did not return a ACPI package as expected.",
   "label": "KlogAcpiEvalReferenceNotPackage"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "[Package] has zero elements",
   "advice": "An ACPI evaluate for a reference returned an illeage package of zero elements.",
   "label": "KlogAcpiEvalReferencePackageZeroElements"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "Expecting a [Reference] package element, found type",
   "advice": "An ACPI evaluate for a reference returned contained an element that was not a reference type.",
   "label": "KlogAcpiEvalReferencePackageElementType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_EMBEDDED_CONTROLLER",
   "pattern": "error obtaining _EC",
   "advice": "The ACPI Embedded Controller Offset Query Control Method _EC failed to evaluate. It is either missing or broken and means the kernel cound not add a SMBUS host controller.",
   "label": "KlogAcpiEcFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "host controller is not configured",
   "advice": "The kernel count not issue a SMBUS transaction because the host controller was not configured. See acpi_smbus_transaction()",
   "label": "KlogSmbusHostController"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Error attaching device data",
   "advice": "The kernel could not register a thermal zone because acpi_attach_data() failed for some reason. The machine may not be able to optimally cool itself and may have overheating issues because of this error.",
   "label": "KlogAcpiThermZoneAttachFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _TSS data: freq is zero",
   "advice": "The _TSS has returned a zero fequency setting in one or more of the package elements.",
   "label": "KlogAcpiTssZeroFrequency"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _TSS data",
   "advice": "The _TSS has returned a NULL data pointer or data which isn't an ACPI package.",
   "label": "KlogAcpiTssBadData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Unknown _TSD:num_entries",
   "advice": "The number of entries in the throlling domain information was not 5.",
   "label": "KlogAcpiTsdIllegalNumEntries"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Unknown _TSD:revision",
   "advice": "The expected TSD revision was not 0.",
   "label": "KlogAcpiTsdBadRevision"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "HARDWARE addr space,NOT supported yet",
   "advice": "The CPU does not seem to support the MSR_IA32_THERM_CONTROL MSR.",
   "label": "KlogAcpiUnsupportedThermControlMsr"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Unknown addr space",
   "advice": "Could not read the hardware specific throttling status, the status register space ID was not a system I/O space or a fixed hardware space.",
   "label": "KlogAcpiThrottleStatusBadRead"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _TSD data",
   "advice": "The _TSD has returned data which isn't valid, either a NULL data pointer or data which isn't an ACPI package has been returned.",
   "label": "KlogAcpiTsdBadData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _PTC control register",
   "advice": "The _PTC control register bit widths or bit offsets are incorrect.",
   "label": "KlogAcpiPtcControlRegisterInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _PTC status register",
   "advice": "The _PTC status register bit widths or bit offsets are incorrect.",
   "label": "KlogAcpiPtcStatusRegisterInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _PTC data (status_register)",
   "advice": "The _PTC status register data (element 1 of the package) was either NULL or too small.",
   "label": "KlogAcpiPtcDataStatusRegister"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _PTC data (control_register)",
   "advice": "The _PTC control register data (element 0 of the package) was either NULL or too small.",
   "label": "KlogAcpiPtcDataControlRegister"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _PTC data",
   "advice": "_PTC did not return a package of two elements, expected a two element package containing bufffers for the control and status register.",
   "label": "KlogAcpiPtcDataBad"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Failed to create sysfs link 'thermal_cooling'",
   "advice": "sysfs_create_link() failed to create the thermal 'thermal_cooling' sysfs entry.",
   "label": "KlogAcpiThermalThermalCoolingSysfs"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Failed to create sysfs link 'device'",
   "advice": "sysfs_create_link() failed to create the thermal 'device' sysfs entry.",
   "label": "KlogAcpiThemalDeviceSysfs"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Setting initial power state",
   "advice": "The call to acpi_bus_update_power() in acpi_fan_add() failed while adding a new fan device.",
   "label": "KlogAcpiFanAddFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_EMBEDDED_CONTROLLER",
   "pattern": "ACPI:.*EC.*input buffer is not empty, aborting transaction",
   "advice": "The ACPI Embedded Controller (EC) driver attempted to perform a read or write transaction but had to abort because the EC was still busy and the input buffer was not emptied within 500ms.  Normally this indicates an EC firmware fault.  One can try increasing the delay using the acpi.ec_delay kernel parameter or writing to /sys/module/acpi/parameters/ec_delay - however this generally does not help much of the EC firmware is buggy.",
   "label": "KlogAcpiEcInputBufferIsNotEmpty"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "ENERGY_PERF_BIAS.*Set to 'normal'.* was 'performance'",
   "advice": "The MSR_IA32_ENERGY_PERF_BIAS was initialized incorrectly and was defaulted to a high performance bias setting.  The kernel has detected this and changed it down to a 'normal' bias setting.  The BIOS vendor should be informed that the MSR is not defaulted to the normal bias setting.",
   "label": "KlogEnergyPerfBiasSetToNormal"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "pnp.*can't evaluate _CRS: 12311",
   "advice": "The _CRS object could not be evaluated because an invalid resource type has been returned. This can lead to misconfigured PNP hardware and may render a system unbootable.",
   "label": "KlogPnpCrsInvalidResourceType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "pnp.*can't evaluate _CRS:",
   "advice": "The _CRS object could not be evaluated, the error code is an ACPI error return code (see include/acpi/acexecp.h in the linux source, this is composed of bottom 12 bits of an error number and upper 4 bits of an AE_CODE_* code. Typically, _CRS evaluation errors can lead to misconfigured PNP hardware and may render a system unbootable.",
   "label": "KlogPnpCrsCannotEvaluate"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "dell_wmi:.*Received unknown WMI event",
   "advice": "The Dell WMI driver has received an unknown WMI event. The driver should handle this new event or the firmware is reporting an incorrect and unknown event.",
   "label": "KlogDellWmiReceivedUnknownWMIEvent"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "dell_wmi:.*bad event status 0x",
   "advice": "The Dell WMI driver has received a bad event status. This should be investigated further.",
   "label": "KlogDellWmiBadEventStatus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "asus_wmi:.*Unknown key.*pressed",
   "advice": "The ASUS WMI driver has received an unknown key event. The driver should handle this new key event or the firmware is reporting an incorrect and unknown event.",
   "label": "KlogAsusWmiUnknownKeypressed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*bad event status 0x",
   "advice": "The HP WMI driver has received a bad event status. This should be investigated further.",
   "label": "KlogHpWmiBadEventStatus"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Failed to create sysfs link 'thermal_cooling'",
   "advice": "sysfs_create_link() failed to create the thermal 'thermal_cooling' sysfs entry.",
   "label": "KlogAcpiThermalThermalCoolingSysfs"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Failed to create sysfs link 'device'",
   "advice": "sysfs_create_link() failed to create the thermal 'device' sysfs entry.",
   "label": "KlogAcpiThemalDeviceSysfs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_EMBEDDED_CONTROLLER",
   "pattern": "ACPI:.*EC.*input buffer is not empty, aborting transaction",
   "advice": "The ACPI Embedded Controller (EC) driver attempted to perform a read or write transaction but had to abort because the EC was still busy and the input buffer was not emptied within 500ms.  Normally this indicates an EC firmware fault.  One can try increasing the delay using the acpi.ec_delay kernel parameter or writing to /sys/module/acpi/parameters/ec_delay - however this generally does not help much of the EC firmware is buggy.",
   "label": "KlogAcpiEcInputBufferIsNotEmpty"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_INFO",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "ENERGY_PERF_BIAS.*Set to 'normal'.* was 'performance'",
   "advice": "This is not exactly a failure but a warning from the kernel. The MSR_IA32_ENERGY_PERF_BIAS was initialized and defaulted to a high performance bias setting. The kernel has detected this and changed it down to a 'normal' bias setting."
   "label": "KlogEnergyPerfBiasSetToNormal"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "pnp.*can't evaluate _CRS: 12311",
   "advice": "The _CRS object could not be evaluated because an invalid resource type has been returned. This can lead to misconfigured PNP hardware and may render a system unbootable.",
   "label": "KlogPnpCrsInvalidResourceType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "pnp.*can't evaluate _CRS:",
   "advice": "The _CRS object could not be evaluated, the error code is an ACPI error return code (see include/acpi/acexecp.h in the linux source, this is composed of bottom 12 bits of an error number and upper 4 bits of an AE_CODE_* code. Typically, _CRS evaluation errors can lead to misconfigured PNP hardware and may render a system unbootable.",
   "label": "KlogPnpCrsCannotEvaluate"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "dell_wmi:.*Received unknown WMI event",
   "advice": "The Dell WMI driver has received an unknown WMI event. The driver should handle this new event or the firmware is reporting an incorrect and unknown event.",
   "label": "KlogDellWmiReceivedUnknownWMIEvent"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "dell_wmi:.*bad event status 0x",
   "advice": "The Dell WMI driver has received a bad event status. This should be investigated further.",
   "label": "KlogDellWmiBadEventStatus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "asus_wmi:.*Unknown key.*pressed",
   "advice": "The ASUS WMI driver has received an unknown key event. The driver should handle this new key event or the firmware is reporting an incorrect and unknown event.",
   "label": "KlogAsusWmiUnknownKeypressed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*bad event status 0x",
   "advice": "The HP WMI driver has received a bad event status. This should be investigated further.",
   "label": "KlogHpWmiBadEventStatus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*Unknown response received",
   "advice": "The HP WMI driver has received a return object that was not of type ACPI_BUFFER. The driver needs to be updated to handle this new return type or there is a bug in the WMI mechanism on this machine.",
   "label": "KlogHpWmiUnknownResponseReceived"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*Unknown buffer length",
   "advice": "The HP WMI driver has received a return buffer that was not the expected size of 8 or 16 bytes. This is probably a bug in the WMI mechanism on this machine.",
   "label": "KlogHpWmiUnknownBufferLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*Unknown key code - 0x",
   "advice": "The HP WMI driver has received a key code that it does not recognise. The driver needs to be updated to handle this new key code.",
   "label": "KlogHpWmiUnknownKeyCode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*Unknown event_id",
   "advice": "The HP WMI driver has received an event ID that it does not recognise. The driver needs to be updated to handle this new event ID.",
   "label": "KlogHpWmiUnknownEventId"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "msi_wmi:.*Unknown key pressed",
   "advice": "The MSI WMI driver has received a key code that it does not recognise. The driver needs to be updated to handle this new key code.",
   "label": "KlogMsiWmiUnknownKeyPressed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Handling Garbled _PRT entry",
   "advice": "BIOS has a garbled _PRT entry; source_name and source_index swapped.",
   "label": "KlogAcpiHandlingGarbledPrtEntry"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _PCT data",
   "advice": "The ACPI _PCT data is invalid.",
   "label": "KlogInvalidPctData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Error.*ACPI path has too many parent prefixes",
   "advice": "A path to an ACPI obejct has too many ^ parent prefixes and references passed the top of the root node. Please check AML for all ^ prefixed ACPI path names.",
   "label": "KlogAcpiPathTooManyParentPrefixes"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_RSDP",
   "pattern": "ACPI Error.*A valid RSDP was not found",
   "advice": "An ACPI-compatible system must provide an RSDP (Root System Description Pointer in the system's low address space. This structures only purpose is to provide the physical address of the RSDT and XSDT.",
   "label": "KlogAcpiValidRsdpNotFound"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_MUTEX",
   "pattern": "ACPI Error.*Cannot release Mutex",
   "advice": "Attempted to release of a Mutex that was not previous acquired. This needs fixing as it could lead to race conditions when operating on a resource that needs to be proteced by a Mutex.",
   "label": "KlogAcpiCannotReleaseMutex"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_EVENT",
   "pattern": "ACPI Error.*Could not disable .* event",
   "advice": "",
   "label": "KlogAcpiCouldNotDisableEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_EVENT",
   "pattern": "ACPI Error.*Could not enable .* event",
   "advice": "",
   "label": "KlogAcpiCouldNotEnableEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_NAMESPACE_LOOKUP",
   "pattern": "ACPI Error.*Namespace lookup failure, AE_ALREADY_EXISTS",
   "advice": "",
   "label": "KlogAcpiNamespaceLookupFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_BUFFER_OVERFLOW",
   "pattern": "ACPI Error.*_SB_._OSC.*AE_AML_BUFFER_LIMIT",
   "advice": "Section 6.2.10.2 of V4.0a of the ACPI specification states that the _OSC Method should be passed an 8 byte buffer of 2 x 32 DWORDs, however it appears that the method is possibly trying to access data outside this buffer. This is a bug in the _OSC method.",
   "label": "KlogAcpiSbOscAeAmlBufferLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": ".*pci.*ACPI _OSC request failed.*returned control mask",
   "advice": "The _OSC method evaluation failed, which will result in disabling PCIe functionality, for example, the Linux kernel has to disable Active State Power Management (ASPM) which means that PCIe power management is not optimally configured.",
   "label": "KlogPciAcpiOscRequestFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_OSC invalid UUID",
   "advice": "The _OSC method indicates it has been passed an invalid UUID, see section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.  Note that it has been observed on some systems that this error is returned because the _OSC has evaluated incorrectly and it returns with an incorrect error setting the OSC invalid UUID error bit.",
   "label": "KlogOscInvalidUuid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_OSC invalid revision",
   "advice": "The _OSC method indicates it has been passed an invalid revision number, see section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.  Note that the revision level is specific to the given UUID.",
   "label": "KlogOscInvalidRevision"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_OSC request failed",
   "advice": "The _OSC method evaluation failed for some unknown reason. This could be that the data passed to it was incorrect or that the method itself is broken. See section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.",
   "label": "KlogOscRequestFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_OSC request failed",
   "advice": "The _OSC method evaluation failed for some unknown reason. This could be that the data passed to it was incorrect or that the method itself is broken. See section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.",
   "label": "KlogOscRequestFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_BUFFER_OVERFLOW",
   "pattern": "ACPI Error.*Field.*exceeds Buffer",
   "advice": "The field exceeds the allocated buffer size. This can lead to unexpected results when fetching data outside this region.",
   "label": "KlogAcpiFieldexceedsBuffer"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_IO_PORT",
   "pattern": "ACPI Error.*Illegal I\/O port address\/length above 64K",
   "advice": "A port address or length has exceeded the maximum allowed 64K address limit. This will lead to unpredicable errors.",
   "label": "KlogAcpiIllegalIOAbove64K"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Error.*Incorrect return type",
   "advice": "An ACPI Method has returned an unexpected and incorrect return type.",
   "label": "KlogAcpiIncorrectReturnType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Error.*Needed .*\\[Buffer\/String\/Package\\], found \\[Integer\\]",
   "advice": "An ACPI Method has returned an Integer type when a Buffer, String or Package was expected.",
   "label": "KlogAcpiNeededBufferOrStringOrPackage"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Error.*Needed .*\\[Reference\\], found \\[Device\\]",
   "advice": "An ACPI Method has returned an Device type when a Reference type was expected.",
   "label": "KlogAcpiNeededReference"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_NO_HANDLER",
   "pattern": "ACPI Error.*No handler for Region",
   "advice": "",
   "label": "KlogAcpiNoHandlerForRegion"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_NO_HANDLER",
   "pattern": "ACPI Error.*Region .* has no handler",
   "advice": "",
   "label": "KlogAcpiRegionHasNoHandler"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Error.*Missing expected return value",
   "advice": "The ACPI Method did not return a value and was expected too. This is a bug and needs fixing.",
   "label": "KlogAcpiMissingExpectedReturnValue"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "Package List length.*larger than.*truncated",
   "advice": "A Method has returned a Package List that was larger than expected.",
   "label": "KlogAcpiPackageListLargerThanExpected"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Error.*Result stack is empty!",
   "advice": "",
   "label": "KlogAcpiResultStackEmpty"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_AML_OPCODE",
   "pattern": "ACPI Error.*Found unknown opcode",
   "advice": "An illegal AML opcode has been found and is ignored. This indicates either badly compiled code or opcode corruption in the DSDT or SSDT tables or a bug in the ACPI execution engine. Recommend disassembing using iasl to find any offending code.",
   "label": "KlogAcpiFoundUnknownOpcode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_AML_OPCODE",
   "pattern": "ACPI Warning.*Detected an unsupported executable opcode",
   "advice": "An illegal AML opcode has been found and is ignored. This indicates either badly compiled code or opcode corruption in the DSDT or SSDT tables or a bug in the ACPI execution engine. Recommend disassembing using iasl to find any offending code.",
   "label": "KlogAcpiDetectedUnsupportedOpCode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "bios32_service.*not present",
   "advice": "The BIOS has found a BIOS32 Service Directory but the BIOS has returned error 0x80 on calling the service, which indicates that the requested service has not been implemented in the firmware.",
   "label": "KlogBios32ServiceNotPresent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "bios32_service.*BIOS bug",
   "advice": "The BIOS has found a BIOS32 Service Directory but the BIOS has returned an error on calling the service, which is unexpected and usually means the firmware is broken.",
   "label": "KlogBios32ServiceBiosBug"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS_IRQ",
   "pattern": "PCI: Error.*when fetching IRQ routing table",
   "advice": "The BIOS has been interrogated for the PCI IRQ routing table but the BIOS returned an error.",
   "label": "KlogPciFetchingIRQRoutingTable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Denied AML access to port",
   "advice": "AML code was accessing an I/O port that was banned from accesses. Ports 0x20-0x21 (PIC0), 0xa0-0xa1 (PIC1), 0x4d0-0x4d1 (ELCR) are always banned. For _OSI() greater or equal to 'Windows 2001' (Windows XP) ports 0x00-0x0f (DMA), 0x40-0x43 (PIT1), 0x48-0x4b (PIT2), 0x70-0x71 (RTC), 0x81-0x83 (DMA1), 0x87 (DMA1L), 0x89-0x8b (DMA2), 0x8f (DMA2L), 0x90-0x91 (ARBC), 0x93-0x94 (SETUP), 0x96-0x97 (POS), 0xc0-0xdf (ISA DMA) and 0xcf8-0xcff (PCI config) are banned.  Since the AML code has been banned from accessing these ports you will get undefined behaviour and the AML code should be fixed.",
   "label": "KlogAcpiDeniedAmlAccessToPort"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method parse\/execution failed.*AE_AML_NO_RETURN_VALUE",
   "advice": "The ACPI Method was expected to return a value and did not.",
   "label": "KlogAcpiMethodNoReturnValue"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_ALREADY_EXISTS",
   "advice": "",
   "label": "KlogAcpiObjectAlreadyExists"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_INVALID_TABLE_LENGTH",
   "advice": "The ACPI Method returned a table of the incorrect length. This can lead to unexepected results.",
   "label": "KlogAcpiInvalidTableLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_BUFFER_LIMIT",
   "advice": "Method failed: ResourceSourceIndex is present but ResourceSource is not.",
   "label": "KlogAcpiBufferLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_NOT_EXIST",
   "advice": "",
   "label": "KlogAcpiObjectDoesNotExist"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_NOT_FOUND",
   "advice": "",
   "label": "KlogAcpiObjectNotFound"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_LIMIT",
   "advice": "",
   "label": "KlogAcpiExecLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_OPERAND_TYPE",
   "advice": "",
   "label": "KlogAcpiOperandType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_TIME",
   "advice": "",
   "label": "KlogAcpiTimeOut"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_PACKAGE_LIMIT",
   "advice": "",
   "label": "KlogAcpiPackageLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_OWNER_ID_LIMIT",
   "advice": "Method failed to allocate owner ID.",
   "label": "KlogAcpiOwnerIdLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_MUTEX_NOT_ACQUIRED",
   "advice": "A Mutex acquire failed, which could possibly indicate that it was previously acquired and not released, or a race has occurred. Some AML code fails to miss Mutex acquire failures, so it is a good idea to verify all Mutex Acquires using the syntaxcheck test.",
   "label": "KlogAcpiMutexNotAcquired"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Error.*SMBus or IPMI write requires Buffer of",
   "advice": "An incorrect SMBus or IPMI write buffer size was used.",
   "label": "KlogAcpiIncorrectWriteBufferSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_EVAL",
   "pattern": "ACPI (Warning|Error).*Evaluating .* failed",
   "advice": "Executing the ACPI Method leaded in an execution failure. This needs investigating.",
   "label": "KlogAcpiEvaluationFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI Warning.*Optional field.*has zero address or length",
   "advice": "An ACPI table contains Generic Address Structure that has an address that is incorrectly set to zero, or a zero length. This needs to be fixed. ",
   "label": "KlogAcpiOptionalFieldZeroAddressOrLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI (Warning|Error).*two DSDT tables",
   "advice": "The FADT table contains a mismatch between the 32 bit pointer (DSDT) and 64 bit pointer (X_DSDT) pointer to the FACS table.  Section 5.2.9 of version 4.0a of the ACPI specification states that X_DSDT should be zero if DSDT is defined, or DSDT should be zero if X_DSDT is zero. With two different pointers defined, the kernel has to make a choice, and opts for the 32 bit pointer. Because these pointers are different, it suggests either one of them is incorrect, or different 32 bit and 64 bit DSDT tables are present in your system, which is NOT complaint with the ACPI specification.  The kernel has to make a choice and opts for the 32 bit DSDT.",
   "label": "KlogAcpiTwoDsdt"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI (Warning|Error).*two FACS tables",
   "advice": "The FADT table contains a mismatch between the 32 bit pointer (FIRMWARE_CTRL) and 64 bit pointer (X_FIRMWARE_CTRL) pointer to the FACS table.  Section 5.2.9 of version 4.0a of the ACPI specification states that X_FIRMWARE_CTRL should be zero if FIRMWARE_CTRL is defined, or FIRMWARE_CTRL should be zero if X_FIRMWARE_CTRL is zero. With two different pointers defined, the kernel has to make a choice, and opts for the 32 bit pointer. Because these pointers are different, it suggests either one of them is incorrect, or different 32 bit and 64 bit FACS tables are present in your system, which is NOT complaint with the ACPI specification.  The kernel has to make a choice and opts for the 32 bit FIRMWARE_CTRL.",
   "label": "KlogAcpiTwoFacs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI Error.*32/64X address mismatch in.*, using 32",
   "advice": "The FADT table contains a mismatch between a 32 bit pointer and a 64 bit Generic Address pointer. Because these pointers are different, it suggests either one of them is incorrect.  If a non-null 32 bit pointer exists, then the kernel will opt for this in preference to the 64 bit pointer even though this is not in accordance to the ACPI specification.",
   "label": "KlogAcpi32Bit64BitAddressMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI (Warning|Error).*32\/64.*(length|address) mismatch in.*tbfadt",
   "advice": "The FADT table contains Generic Address Structure that has a mismatch between the 32 bit and 64 bit versions of an address. This should be fixed so there are no mismatches. ",
   "label": "KlogAcpi32Bit64BitAddressMismatchInFadt"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI (Warning|Error).*32\/64.*(length|address) mismatch in",
   "advice": "A table contains Generic Address Structure that has a mismatch between the 32 bit and 64 bit versions of an address. This should be fixed so there are no mismatches. ",
   "label": "KlogAcpi32Bit64BitAddressMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*Return Package type mismatch",
   "advice": "ACPI AML interpreter executed a Method that returned a package with incorrectly typed data. The offending method needs to be fixed.",
   "label": "KlogAcpiReturnPackageTypeMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*Return Package has no elements",
   "advice": "ACPI AML interpreter executed a Method that returned a package with no elements inside it. This is most probably a bug in the Method and needs to be fixed.",
   "label": "KlogAcpiReturnPackageZeroElements"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*Return Package is too small",
   "advice": "ACPI AML interpreter executed a Method that returned a package with too few elements inside it. This is most probably a bug in the Method and needs to be fixed.",
   "label": "KlogAcpiReturnPackageTooSmall"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_TABLE_CHECKSUM",
   "pattern": "ACPI Warning.*Incorrect checksum in table",
   "advice": "The ACPI table listed above has an incorrect checksum, this could be a BIOS bug or due to table corruption.",
   "label": "KlogAcpiIncorrectTableChecksum"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*_BQC returned an invalid level",
   "advice": "Method _BQC (Brightness Query Current) returned an invalid display brightness level.",
   "label": "KlogAcpiBqcReturnedInvalidLevel"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Warning.*Could not enable fixed event",
   "advice": "",
   "label": "KlogAcpiCannotEnableFixedEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*Return type mismatch",
   "advice": "The ACPI Method returned an incorrect type, this should be fixed.",
   "label": "KlogAcpiReturnTypeMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARAMETER",
   "pattern": "ACPI Warning.*Parameter count mismatch",
   "advice": "The ACPI Method was executing with a different number of parameters than the Method expected. This should be fixed.",
   "label": "KlogAcpiParameterCountMistmatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARAMETER",
   "pattern": "ACPI Warning.*Insufficient arguments",
   "advice": "The ACPI Method has not enough arguments as expected. This should be fixed.",
   "label": "KlogAcpiInsufficientArguments"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PACKAGE",
   "pattern": "ACPI Warning.*Package has no elements",
   "advice": "The ACPI Method returned a package with no elements in it, and some were exepected.This should be fixed.",
   "label": "KlogAcpiPackageHasNoElements"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*Converted Buffer to expected String",
   "advice": "Method returned a Buffer type instead of a String type and ACPI driver automatically converted it to a String.  It is worth fixing this in the DSDT or SSDT even if the kernel fixes it at run time.",
   "label": "KlogAcpiConvertedBufferToString"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PACKAGE",
   "pattern": "ACPI Warning.*Return Package type mistmatch at index",
   "advice": "The ACPI Method returned a package that contained data of the incorrect data type. This data type needs fixing.",
   "label": "KlogAcpiReturnPackageTypeMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_LENGTH",
   "pattern": "ACPI Warning.*Invalid length for.*fadt",
   "advice": "This item in the FADT is the incorrect length. Should be corrected.",
   "label": "KlogAcpiFadtInvalidLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THROTTLING",
   "pattern": "ACPI Warning.*Invalid throttling state",
   "advice": "",
   "label": "KlogAcpiInvalidThrottlingState"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_EMBEDDED_CONTROLLER",
   "pattern": "ACPI Exception:.*AE_TIME.*Returned by Handler for.*[EmbeddedControl]",
   "advice": "This is most probably caused by when a read or write operation to the EC memory has failed because of a timeout waiting for the Embedded Controller to complete the transaction.  Normally, the kernel waits for 500ms for the Embedded Controller status port to indicate that a transaction is complete, but in this case it has not and a AE_TIME error has been returned. ",
   "label": "KlogAcpiTimeOutReturnedByHandler"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Warning",
   "advice": "ACPI AML intepreter has found some non-conforming AML code. This should be investigated and fixed.",
   "label": "KlogAcpiBadAmlCode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_APIC",
   "pattern": "ACPI.*BIOS bug: multiple APIC\/MADT found, using",
   "advice": "The kernel has detected more than one ACPI Multiple APIC Description Table (MADT) (these tables have the \"APIC\" signature). There should only be one MADT and the kernel will by default select the first one. However, one can override this and select the Nth MADT using acpi_apic_instance=N.",
   "label": "KlogAcpiMultipleApicMadtFound"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid physical address in GAR",
   "advice": "ACPI Generic Address is invalid",
   "label": "KlogAcpiInvalidPhysicalAddress"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS_AMD_POWERNOW",
   "pattern": "\\[Firmware Bug\\]: powernow-k8.*(No PSB or ACPI _PSS objects|No compatible ACPI _PSS|Your BIOS does not provide ACPI _PSS objects)",
   "advice": "The _PSS object (Performance Supported States) is an optional object that indicates the number of supported processor performance states. The powernow-k8 driver source states: If you see this message, complain to BIOS manufacturer. If he tells you \"we do not support Linux\" or some similar nonsense, remember that Windows 2000 uses the same legacy mechanism that the old Linux PSB driver uses. Tell them it is broken with Windows 2000. The reference to the AMD documentation is chapter 9 in the BIOS and Kernel Developer's Guide, which is available on www.amd.com.",
   "label": "KlogAcpiAmdK8ExpectedPssObjects"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS_AMD_POWERNOW",
   "pattern": "\\[Firmware Bug\\]: powernow-k8.*Try again with latest",
   "advice": "",
   "label": "KlogAcpiTryNewAmdFirmware"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid bit width in GAR",
   "advice": "ACPI Generic Address width must be 8, 16, 32 or 64",
   "label": "KlogAcpiGarInvalidBitWidth"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid address space type in GAR",
   "advice": "ACPI Generic Address space type must be system memory or system IO space.",
   "label": "KlogAcpiGarInvalidAddressType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*no secondary bus range in _CRS",
   "advice": "_CRS Method should return a secondary bus address for the status\/command port. The kernel is having to guess this based on the _BBN or assume it's 0x00-0xff.",
   "label": "KlogAcpiCrsSecondaryBusRangeMissing"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid BIOS _PSS frequency",
   "advice": "_PSS (Performance Supported States) package has an incorrectly define core frequency (first DWORD entry in the _PSS package).",
   "label": "KlogAcpiInvalidPssFrequency"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BRIGHTNESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*No _BQC method",
   "advice": "_BQC (Brightness Query Current level) seems to be missing. This method returns the current brightness level of a built-in display output device.",
   "label": "KlogAcpiMissingBqc"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BRIGHTNESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*brightness control misses _BQC function",
   "advice": "_BQC (Brightness Query Current level) seems to be missing. This method returns the current brightness level of a built-in display output device.",
   "label": "KlogAcpiMissingBqc"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]: BIOS needs update for CPU frequency support",
   "advice": "Having _PPC but missing frequencies (_PSS, _PCT) is a good hint that the BIOS is older than the CPU and does not know the CPU frequencies.",
   "label": "KlogAcpiMissingPssPct"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]: ERST.*ERST table is invalid",
   "advice": "The Error Record Serialization Table (ERST) seems to be invalid. This normally indicates that the ERST table header size is too small, or the table size (excluding header) is not a multiple of the ERST entries.",
   "label": "KlogAcpiErstInvalid"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "\\[Firmware Bug\\]:.*Invalid critical threshold",
   "advice": "ACPI _CRT (Critical Trip Point) is returning a threshold lower than zero degrees Celsius which is clearly incorrect.",
   "label": "KlogAcpiCrtInvalidThreshold"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "\\[Firmware Bug\\]:.*No valid trip found",
   "advice": "No valid ACPI _CRT (Critical Trip Point) was found.",
   "label": "KlogAcpiNoValidCrt"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BRIGHTNESS",
   "pattern": "\\[Firmware Bug\\]:.*_BCQ is used instead of _BQC",
   "advice": "ACPI Method _BCQ was defined (typo) instead of _BQC - this should be fixed.however the kernel has detected this and is working around this typo.",
   "label": "KlogAcpiBcqInsteadOfBqc"
  }, 
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "MPTABLE: bad signature",
   "advice": "The MultiProcessor table has an incorrect signature, it should be PCMP. The kernel cannot trust the table and has disabled SMP support.",
   "label": "KlogBiosMptableBadSignature"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "MPTABLE: checksum error",
   "advice": "The MultiProcessor table has an incorrect checksum. The kernel cannot trust the table and has disabled SMP support.",
   "label": "KlogBiosMptableChecksumError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "MPTABLE: bad table version",
   "advice": "The MultiProcessor table has an incorrect version. It should be 0x01 or 0x04 (for versions 1.1 and 1.4 respectively). The kernel cannot trust the table and has disabled SMP support.",
   "label": "KlogBiosMptableBadVersion"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "MPTABLE: null local APIC address",
   "advice": "The MultiProcessor table contains a NULL Local APIC address but the Local APIC address must be defined. The kernel has disabled SMP support.",
   "label": "KlogBiosMptableNullLapicAddress"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "MPTABLE: no processors registered",
   "advice": "The MultiProcessor table contains no Processor Entry Fields, and hence there are no CPUs defined. The kernel has no option but to disable SMP support.",
   "label": "KlogBiosMptableNoProcessors"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "BIOS bug.*no explicit IRQ entries.*using default mptable",
   "advice": "The MultiProcessor table contains no IRQ Entry Fields, and hence there are no IRQs defined. The table is broken and should be fixed. The kernel will set up the low 16 IO-APIC pins to the ISA defaults in the hope the machine may work.",
   "label": "KlogBiosMptableNoIRQentries"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS_IRQ",
   "pattern": "BIOS bug.*timer not connected to IO-APIC",
   "advice": "The BIOS is reporting the ExtINTA I/O APIC input from the cascaded 8259A as the timer interrupt input.  The kernel has detected just one pin, so it has to check the timer directly and through the 8259A because of the broken BIOS reporting.",
   "label": "KlogBiosTimerNotConnectedtoIoApic"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS_IRQ",
   "pattern": "BIOS bug,.*IO-APIC.*ID is.*in the MPC table.*",
   "advice": "The IO-APIC id in the MPC table is wrong and the kernel has detected this and attempted to fix it. The MPC table in the firmware needs to be fixed.",
   "label": "KlogBiosIoApicInMpcTable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS_IRQ",
   "pattern": "BIOS bug,.*IO-APIC.*ID is already used!",
   "advice": "The IO-APIC id has been defined more than once in the MPC table, which is a firmware bug and should be fixed. The kernel has detected this and skopped this duplication to avoid stuck on smp_invalidate_needed IPI wait' messages.",
   "label": "KlogBiosIoApicIdAlreadyUsed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "WARNING.*BIOS bug.*CPU MTRRs don't cover all of memory, losing",
   "advice": "The Memory Type Range Registers (MTRRs) which define memory caching policy are misconfigued by the BIOS and don't appear to cover all available physical memory. The kernel has detected this and has reduced the amount of memory available to be safe. Either check that the BIOS memory caching options are set correctly or contact your BIOS vendor to get this fixed.",
   "label": "KlogBiosCpuMtrrMisconfigured"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*no more MTRRs available",
   "advice": "A device driver has tried to allocate a Memory Type Range Register (MTRR) to optimially configure a caching policy on a memory region but there are no more free MTRRs available.  Generally the firmware should allow for one or two free MTRRs for drivers to allocate.  The system will have a sub-optimally configured memory region and this may severely impact on performance.",
   "label": "KlogBiosNoMoreMtrrsAvailable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern":  "[drm].*MTRR allocation failed.*Graphics performance may suffer",
   "advice": "The DRM driver has tried to allocate a Memory Type Range Register (MTRR) but there are no more free MTRRs available. The system will have a sub-optimally configured graphics memory region and this may severely impact on graphics rendering throughput and performance.  The firmware should allow for one or two free MTRRs, but it hasn't, which is probably a firmware bug.",
   "label": "KlogBiosMtrrAllocationFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*your BIOS has configured an incorrect mask, fixing it",
   "advice": "The Memory Type Range Registers (MTRRs) which define memory caching policy are misconfigued by the BIOS. In this case, the mask is incorrectly set and the kernel has detected this and worked around the firmware bug.",
   "label": "KlogBiosMtrrIncorrectMask"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*your CPUs had inconsistent fixed MTRR settings",
   "advice": "The fixed Memory Type Range Registers (MTRRs) which define memory caching policy are not consistent across all CPUs which is a firmware bug. The kernel has worked around this bug, but it may be worth getting the BIOS vendor to fix this.",
   "label": "KlogBiosMtrrsInconsistentAcrossCPUs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*your CPUs had inconsistent variable MTRR settings",
   "advice": "The variable Memory Type Range Registers (MTRRs) which define memory caching policy are not consistent across all CPUs which is a firmware bug. The kernel has worked around this bug, but it may be worth getting the BIOS vendor to fix this.",
   "label": "KlogBiosMtrrsInconsistentAcrossCPUs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*your CPUs had inconsistent MTRRdefType settings",
   "advice": "The Memory Type Range Registers (MTRRs) which define memory caching policy do not have a MTRRdefType consistently set across all CPUs which is a firmware bug. The kernel has worked around this bug, but it may be worth getting the BIOS vendor to fix this.",
   "label": "KlogBiosMtrrDefTypeIncosistent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*base.*is not 4 MiB aligned",
   "advice": "The Memory Type Range Registers (MTRRs) for Intel PPro CPUs with stepping < 8 must be 4 MiB aligned and not touch 0x70000000 -> 0x7003FFFF. This BIOS misconfiguration and should be fixed.",
   "label": "KlogBiosMtrrNot4MbAligned"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITIICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU",
   "advice": "The Memory Type Range Registers (MTRRs) for Intel PPro CPUs with stepping < 8 must not touch region 0x70000000 -> 0x7003FFFF. This BIOS misconfiguration may hang the CPU and should be fixed.",
   "label": "KlogBiosMtrrMayHangCPU"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*base.*is not aligned on a size.*boundary",
   "advice": "The Memory Type Range Registers (MTRRs) must be correctly aligned. This BIOS misconfiguration and should be fixed.",
   "label": "KlogBiosMtrrNotAlignedCorrectly"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": ".*defines _DOD but not _DOS",
   "advice": "ACPI Method _DOD (Enumerate all devices attached to display adapter) is defined but we should also have _DOS (Enable\/Disable output switching) defined but it's been omitted. This can cause display switching issues.",
   "label": "KlogAcpiDodWithNoDos"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "WARNING:.*bogus zero IO-APIC address found in MPTABLE",
   "advice": "An IO-APIC address of zero has been found in the MPTABLE and is thus treated as misconfigured or bogus. I/O APIC support has been disabled. This is considered a firmware bug and the MPTABLE needs to be fixed.",
   "label": "KlogAcpiBogusIoApicInMptable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "WARNING:.*Bogus.*APIC address found in table",
   "advice": "An IO-APIC address of zero has been found in the MPTABLE and is thus treated as misconfigured or bogus. I/O APIC support has been disabled. This is considered a firmware bug and the MPTABLE needs to be fixed.",
   "label": "KlogAcpiBogusIoApicInMptable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]:.*Duplicate ACPI video bus",
   "advice": "Try video module parameter video.allow_duplicates=1 if the current driver does't work.",
   "label": "KlogAcpiDuplicateAcpiVideoBus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_PCI_EXPRESS",
   "pattern": "\\[Firmware Bug\\]:.*PCI.*MMCONFIG.*not reserved in ACPI motherboard resources",
   "advice": "It appears that PCI config space has been configured for a specific device but does not appear to be reserved by the ACPI motherboard resources.",
   "label": "KlogAcpiMmconfigNotReserved"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]: PCI.*not reserved in ACPI motherboard resources",
   "advice": "PCI firmware bug. Please see the kernel log for more details.",
   "label": "KlogPciNotReserved"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_INFO",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]:.*_OSI.*Linux.*ignored",
   "advice": "This is not exactly a failure mode but a warning from the kernel. The _OSI() method has implemented a match to the 'Linux' query in the DSDT and this is redundant because the ACPI driver matches onto the Windows _OSI strings by default.",
   "label": "KlogAcpiOsiLinuxIgnored"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]: ACPI:",
   "advice": "ACPI driver has detected an ACPI bug. This generally points to a bug in an ACPI table. Examine the kernel log for more details.",
   "label": "KlogAcpiFirmwareError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]:.*",
   "advice": "The kernel has detected a Firmware bug in the BIOS or ACPI which needs investigating and fixing.",
   "label": "KlogAcpiFirmwareError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "PCI.*BIOS Bug:",
   "advice": "",
   "label": "KlogBiosBug"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_NAMESPACE_LOOKUP",
   "pattern": "ACPI Error.*Namespace lookup failure, AE_NOT_FOUND",
   "advice": "The kernel has detected an error trying to execute an Method and it cannot find an object. This is indicates a bug in the DSDT or SSDT AML code.",
   "label": "KlogAcpiNamespaceLookupFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.+psparse",
   "advice": "The ACPI engine has failed to execute some AML. The error message above lists the method that caused this error.",
   "label": "KlogAcpiParseOrExecFailure"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Error",
   "advice": "The kernel has most probably detected an error while executing ACPI AML. The error lists the ACPI driver module and the line number where the bug has been caught and the method that caused the error.",
   "label": "KlogAcpiExecFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "\\*\\*\\* Error.*Method execution failed",
   "advice": "Execution of an ACPI AML method failed.",
   "label": "KlogAcpiExecFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "\\*\\*\\* Error.*Method execution failed.*AE_AML_METHOD_LIMIT",
   "advice": "ACPI method reached maximum reentrancy limit of 255 - infinite recursion in AML in DSTD or SSDT",
   "label": "KlogAcpiRecursionTooDeep"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "\\*\\*\\* Error.*Method reached maximum reentrancy limitACPI method has reached reentrancy limit, this is a recursion bug in the AML",
   "advice": "",
   "label": "KlogAcpiRecursionTooDeep"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "\\*\\*\\* Error.*Return object type is incorrect",
   "advice": "Return object type is not the correct type, this is an AML error in the DSDT or SSDT",
   "label": "KlogAcpiReturnObjectTypeIncorrect"
  } 
 ], 
 "pm_error_warning_patterns":
 [
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Failed to prepare device",
   "advice": "dpm_prepare() failed to prepare all non-sys devices for a system PM transition. The device should be listed in the error message.",
   "label": "PmFailedToPrepareDevice"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Some devices failed to power down",
   "advice": "dpm_suspend_noirq failed because some devices did not power down ",
   "label": "PmDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Some system devices failed to power down",
   "advice": "sysdev_suspend failed because some system devices did not power down.",
   "label": "PmSystemDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Error",
   "advice": "",
   "label": "PmError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_NONE",
   "pattern": "PM: Some devices failed to power down",
   "advice": "",
   "label": "PmDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Restore failed, recovering",
   "advice": "A resume from hibernate failed when calling hibernation_restore()",
   "label": "PmResumeFromHibernateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Resume from disk failed",
   "advice": "",
   "label": "PmResumeFromDiskFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Not enough free memory",
   "advice": "There was not enough physical memory to be able to generate a hibernation image before dumping it to disc.",
   "label": "PmNotEnoughFreeMemory"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Memory allocation failed",
   "advice": "swusp_alloc() failed trying to allocate highmem and failing that non-highmem pages for the suspend image. There is probably just not enough free physcial memory available.",
   "label": "PmMemoryAllocationFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Image mismatch",
   "advice": "Mismatch in kernel version, system type, kernel release version or machine id between suspended kernel and resumed kernel.",
   "label": "PmKernelMismatch"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Some devices failed to power down",
   "advice": "",
   "label": "PmDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Some devices failed to suspend",
   "advice": "",
   "label": "PmDevicesFailedToSuspend"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: can't read",
   "advice": "Testing suspend cannot read RTC",
   "label": "PmCannotReadRealTimeClock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: can't set",
   "advice": "Testing suspend cannot set RTC",
   "label": "PmCannotSetRealTimeClock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: suspend test failed, error",
   "advice": "",
   "label": "PmSuspendTestFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: can't test ",
   "advice": "",
   "label": "PmCannotTest"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: no wakealarm-capable RTC driver is ready",
   "advice": "",
   "label": "PmNoWakeAlarmRealTimeClock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Adding page to bio failed at",
   "advice": "An attempt to write the hibernate image to disk failed because a write BIO operation failed. This is usually a result of some physical hardware problem.",
   "label": "PmPhysicalDiskWriteError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Swap header not found",
   "advice": "An attempt to write a hibernate image to disk failed because a valid swap device header could not be found. Make sure there is a formatted swap device on the machine and it is added using swapon -a.",
   "label": "PmSwapHeaderNotFound"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Cannot find swap device",
   "advice": "An attempt to write a hibernate image to disk failed because the swap device could not be found. Make sure there is a formatted swap device on the machine and it is added using swapon -a.",
   "label": "PmCannotFindSwapDevice"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Not enough free swap",
   "advice": "Hibernate failed because the swap parition was probably too small.",
   "label": "PmNotEnoughFreeSwap"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Image device not init",
   "advice": "",
   "label": "PmImageDeviceNotInitialised"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Please power down manually",
   "advice": "",
   "label": "PMPowerDownManually"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "check_for_bios_corruption",
   "advice": "The BIOS seems to be corrupting the first 64K of memory when doing suspend\/resume. Setting bios_corruption_check=0 will disable this check.",
   "label": "PmBiosCorruptFirst64K"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "WARNING: at.*hpet_next_event",
   "advice": "Possibly an Intel I\/O controller hub HPET Write Timing issue: A read transaction that immediately follows a write transaction to the HPET TIMn_COMP Timer 0 (108h), HPET MAIN_CNT (0F0h), or TIMn_CONF.bit 6 (100h) may return an incorrect value.  This is known to cause issues when coming out of S3.",
   "label": "PmHpetWriteTimingIssue"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "BUG: soft lockup.*stuck for 0s",
   "advice": "Softlock errors that occur when coming out of S3 may be tripped by TSC warping.  It may be worth trying the notsc kernel parameter and repeating S3 tests to see if this solves the problem.",
   "label": "PmProcessSoftLockup"
  }
 ] 
}
